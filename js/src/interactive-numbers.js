// Generated by CoffeeScript 1.4.0
(function() {

  (function() {
    "use strict";

    var $options, CodeMirror, attachInteractivity, editing, escodegen, esprima, findLiterals, nextId, setInteractive;
    esprima = require("esprima");
    escodegen = require("escodegen");
    CodeMirror = global.CodeMirror;
    exports.interactiveOptions = $options = {};
    editing = false;
    setInteractive = function(cm, changeObj) {
      var clsName, currentText, editableWidget, end, hasReloaded, key, mark, marks, newTree, pos, range, scrubbableLinks, start, syntax, toRun, val, widgets, _i, _len;
      if (!editing) {
        editing = true;
        scrubbableLinks = [];
        key = val = newTree = range = pos = start = end = void 0;
        hasReloaded = false;
        toRun = [];
        clsName = "scrub_widget";
        currentText = cm.getValue() || cm.options.value;
        marks = cm.getAllMarks();
        for (_i = 0, _len = marks.length; _i < _len; _i++) {
          mark = marks[_i];
          mark.clear();
        }
        try {
          syntax = findLiterals(cm, esprima.parse(currentText, {
            range: true
          }));
          widgets = [];
          $options.values = syntax.values;
          for (key in syntax.values) {
            val = syntax.values[key];
            start = val.start;
            end = val.end;
            editableWidget = document.createElement("span");
            editableWidget.className = clsName;
            editableWidget.textContent = val.value;
            editableWidget.id = key;
            widgets.push(editableWidget);
            range = cm.markText(start, end, {
              handleMouseEvents: true,
              replacedWith: editableWidget,
              shared: true,
              addToHistory: true
            });
            attachInteractivity(editableWidget, val, cm);
          }
        } catch (e) {
          console.log(e);
        }
        return editing = false;
      }
    };
    attachInteractivity = function(ele, val, cm) {
      return ele.addEventListener("mousedown", function(e) {
        var delta, moved, mx, my, orig, up;
        e.preventDefault();
        mx = e.pageX;
        my = e.pageY;
        orig = Number(ele.textContent);
        delta = orig;
        ele.classList.add("dragging");
        moved = function(e) {
          var d;
          e.preventDefault();
          d = Number((Math.round((e.pageX - mx) / 2) + orig).toFixed(5));
          ele.textContent = d;
          $options.values[ele.id].value = d;
          cm.replaceRange(String(d), val.start, val.end);
          if ($options.onChange) {
            return $options.onChange($options.values);
          }
        };
        window.addEventListener("mousemove", moved);
        up = function(e) {
          window.removeEventListener("mousemove", moved);
          window.removeEventListener("mouseup", up);
          return ele.classList.remove("dragging");
        };
        return window.addEventListener("mouseup", up);
      });
    };
    findLiterals = function(cm, tree) {
      var markLiterals, nextId, prefix, recursiveWalk, _values;
      _values = {};
      prefix = "interactive_";
      nextId = 0;
      markLiterals = function(e) {
        var id;
        if (e.type === "Literal" && typeof e.value === "number") {
          if (nextId >= 2048) {
            nextId = 0;
          }
          id = nextId++;
          return _values[prefix + id] = {
            range: e.range,
            value: e.value,
            start: cm.posFromIndex(e.range[0]),
            end: cm.posFromIndex(e.range[1])
          };
        } else {
          return recursiveWalk(e, markLiterals);
        }
      };
      recursiveWalk = function(tree, f) {
        var i, key, len, val;
        i = void 0;
        key = void 0;
        val = void 0;
        if (tree instanceof Array) {
          len = tree.length;
          i = 0;
          while (i < len) {
            val = tree[i];
            if (typeof val === "object" && val !== null) {
              f(val);
            }
            i++;
          }
        } else {
          for (key in tree) {
            val = tree[key];
            if (typeof val === "object" && val !== null) {
              f(val);
            }
          }
        }
        return tree;
      };
      return {
        ast: recursiveWalk(tree, markLiterals),
        values: _values
      };
    };
    nextId = 1;
    return global.CodeMirror.defineOption("interactiveNumbers", {}, function(cm, val, old) {
      var prev;
      prev = old && old !== CodeMirror.Init;
      if (val) {
        $options = val;
        cm.on("change", setInteractive);
        return setInteractive(cm);
      }
    });
  })();

}).call(this);
